Tetris.Storage = function(clock, domRoot) {	this.clock = clock;	this.dom = {};	this.dom.root = domRoot;	this.shapes = [];	this.powers = [1,2,4,8,16,32,64,128];	this.clock.addTickListener(this);};//variablesTetris.Storage.prototype.clock = undefined;Tetris.Storage.prototype.dom = undefined;Tetris.Storage.prototype.shapes = undefined;Tetris.Storage.prototype.shapesTodo = 5;Tetris.Storage.prototype.blocksPerShape = 4;Tetris.Storage.prototype.allowLess = false;Tetris.Storage.prototype.maxWidth = 10;Tetris.Storage.prototype.maxHeight = 10;//methodsTetris.Storage.prototype.getShape = function() {	var i, j, ret = this.shapes.shift();	for (i = 0, j = this.shapes.length; i < j; i++) {		this.shapes[i].moveBy(new Tetris.Pos(0, -4));	}	ret.moveTo(new Tetris.Pos(ret.nullPos.x, 0));	return ret;};Tetris.Storage.prototype.generateShape = function(offsetPos) {	var blocks, shape;	blocks = this.generateBlocks(this.blocksPerShape, this.allowLess);	offsetPos.x -= parseInt(blocks.length/2);	shape = new Tetris.Shape(this.clock, blocks, offsetPos, this.colorize(blocks));	shape.setParent(this.dom.root);	return shape;};Tetris.Storage.prototype.generateBlocks = function(blocksPerShape, allowLess) {	var posX = 0, posY = 0, 		lowX = 0, lowY = 0,		highX = 0, highY = 0,		arrX = [], arrY = [],		i, width, k, height, r,		blocks;	for (i = 0; i < blocksPerShape; i++) {		r = parseInt(Math.random() * 4);		switch (r) {			case 0:	posX++;	break;			case 1:	posX--;	break;			case 2:	posY++;	break;			case 3:	posY--;	break;		}		arrX.push(posX);		arrY.push(posY);	}	lowX = Math.min.apply(undefined, arrX);	lowY = Math.min.apply(undefined, arrY);	highX = Math.max.apply(undefined, arrX);	highY = Math.max.apply(undefined, arrY);	width = highX - lowX;	height = highY - lowY;	width = height = Math.max(width, height);	blocks = [];	for (i = 0; i <= width; i++) {		blocks[i] = [];		for (k = 0; k <= height; k++) {			blocks[i][k] = Tetris.Board.BLOCK_EMPTY;		}	}	r = 0;	while (arrX.length) {		posX = arrX.shift() - lowX;		posY = arrY.shift() - lowY;		if (blocks[posX][posY] === Tetris.Board.BLOCK_EMPTY) {			blocks[posX][posY] = new Tetris.Block(this.clock, new Tetris.Pos(posX, posY));			r++;		}			}	return (allowLess || r === blocksPerShape)		? blocks		: this.generateBlocks(blocksPerShape, allowLess);};Tetris.Storage.prototype.colorize = function(blocks) {	return [parseInt(Math.random() * 256), parseInt(Math.random() * 256), parseInt(Math.random() * 256)];};Tetris.Storage.prototype.tick = function(keysPressed) {	if (this.shapesTodo > this.shapes.length) {		var shape = this.generateShape(new Tetris.Pos(5, this.shapes.length * 4));		this.shapes.push(shape);	}};