Tetris.Board = function(clock, domRoot) {	var i, j;	this.clock = clock;	this.dom = {};	this.dom.root = domRoot;		this.blocks = [];	for (i = 0; i < this.width; i++) {		this.blocks[i] = []		for (j = 0; j < this.height; j++) {			this.blocks[i][j] = Tetris.Board.BLOCK_EMPTY;//new Tetris.Block(this.clock, new Tetris.Pos(i, j), this.dom.root);		}	}	this.dom.root.setAttribute("style", "width: "+(this.width*BLOCK_SIZE)+"px; height: "+(this.height*BLOCK_SIZE)+"px;");	this.clock.addTickListener(this);};//variablesTetris.Board.BLOCK_EMPTY = 0;Tetris.Board.prototype.clock = undefined;Tetris.Board.prototype.dom = undefined;Tetris.Board.prototype.blocks = undefined;Tetris.Board.prototype.width = 10;Tetris.Board.prototype.height = 20;//methodsTetris.Board.prototype.canMoveShape = function(shape, offsetPos) {	var shapeX, shapeY, boardX, boardY, centerX, centerY;	centerX = offsetPos.x + shape.nullPos.x;	centerY = offsetPos.y + shape.nullPos.y;	for (shapeX = 0; shapeX < shape.width; shapeX++) {		for (shapeY = 0; shapeY < shape.height; shapeY++) {			boardX = centerX + shapeX;			boardY = centerY + shapeY;			if (shape.blocks[shapeX][shapeY]) {				if (boardX < 0 || boardX >= this.width				 || boardY < 0 || boardY >= this.height) {					return false;				}				if (this.blocks[boardX][boardY]) {					return false;				}			}		}	}	return true;};Tetris.Board.prototype.doMoveShape = function(shape, offsetPos) {	shape.moveBy(offsetPos);	return this.doesCollide(shape);};Tetris.Board.prototype.placeShape = function(shape) {	var shapeX, shapeY, boardX, boardY, centerX, centerY, chkRows = {};	centerX = shape.nullPos.x;	centerY = shape.nullPos.y;	for (shapeX = 0; shapeX < shape.width; shapeX++) {		for (shapeY = 0; shapeY < shape.height; shapeY++) {			boardX = centerX + shapeX;			boardY = centerY + shapeY;			if (shape.blocks[shapeX][shapeY]) {				chkRows[boardY] = undefined;				if (this.blocks[boardX][boardY]) {					alert("ERROR LINE 61\n" + this.blocks);				}				this.blocks[boardX][boardY] = shape.blocks[shapeX][shapeY];			}		}	}	this.checkRows(chkRows);	return true;};Tetris.Board.prototype.doesCollide = function(shape) {	return !this.canMoveShape(shape, new Tetris.Pos(0, 1));};Tetris.Board.prototype.checkRows = function(rowNums) {	var r, i, delRows = {};	rowNums = {		0 : undefined,		1 : undefined,		2 : undefined,		3 : undefined,		4 : undefined,		5 : undefined,		6 : undefined,		7 : undefined,		8 : undefined,		9 : undefined,		10 : undefined,		11 : undefined,		12 : undefined,		13 : undefined,		14 : undefined,		15 : undefined,		16 : undefined,		17 : undefined,		18 : undefined,		19 : undefined	}	rows: for (r in rowNums) {		for (i = 0; i < this.width; i++) {			if (this.blocks[i][r] === Tetris.Board.BLOCK_EMPTY) {				continue rows;			}		}		delRows[r] = undefined;	}		return this.removeRows(delRows);}Tetris.Board.prototype.removeRows = function(rowNums) {	var r, i, j, count = 0, downMove = [], downPos = new Tetris.Pos(0, 1);	for (r in rowNums) {		for (i = 0; i < this.width; i++) {			this.blocks[i][r].destroy();			this.blocks[i][r] = 0;		}		downMove.push(parseInt(r));	}	while (downMove.length) {		r = downMove.pop() + count;		for (j = r; j >= 0; j--) {			for (i = 0; i < this.width; i++) {				if (this.blocks[i][j]) {					this.blocks[i][j].moveBy(downPos);					this.blocks[i][j + 1] = this.blocks[i][j];					this.blocks[i][j] = Tetris.Board.BLOCK_EMPTY;				}			}		}		count++;	}}Tetris.Board.prototype.tick = function(keysPressed) {	};